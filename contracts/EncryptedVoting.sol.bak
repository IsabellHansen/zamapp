// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.28;

import "@fhevm/solidity/contracts/FHE.sol";

/**
 * @title SecureVote - Advanced Encrypted Voting
 * @dev Secure encrypted voting system with democratic consensus and governance
 * @notice This contract provides encrypted voting with comprehensive consensus management
 * @author SecureVote Labs
 */
contract SecureVote {
    using FHE for ebool;
    using FHE for euint64;

    // ============= EVENTS =============
    event VotingCreated(string topic, uint256 deadline);
    event VoteCasted(address indexed voter);
    event DecryptionRequested(uint256 requestId);
    event ResultsDecrypted(uint64 yesVotes, uint64 noVotes);
    event EmergencyStop(address indexed admin, uint256 timestamp);
    event ChainlinkPhaseTransition(VotingStatus from, VotingStatus to);

    // ============= ERRORS =============
    error VotingNotActive();
    error AlreadyVoted();
    error VotingEnded();
    error Unauthorized();
    error InvalidTimeframe();
    error EmergencyActive();
    error DecryptionNotReady();

    // ============= ENUMS =============
    enum VotingStatus {
        ACTIVE,           // Chainlink voting phase active
        ENDED,            // Oracle voting completed
        DECRYPTING,       // Data feed revelation in progress
        RESULTS_AVAILABLE // Chainlink results revealed
    }

    // ============= STATE VARIABLES =============
    address public immutable admin;
    string public votingTopic;
    uint256 public votingDeadline;
    VotingStatus public currentStatus;
    uint256 public minimumQuorum;
    uint256 public votingRewardPool;
    
    // Chainlink voting state
    euint64 private encryptedYesVotes;
    euint64 private encryptedNoVotes;
    uint64 public decryptedYesVotes;
    uint64 public decryptedNoVotes;
    bool public resultsDecrypted;
    
    // Oracle participation tracking
    mapping(address => bool) public hasVoted;
    uint256 public totalVoters;
    uint256 public votingStartTime;
    
    // Emergency controls
    bool public emergencyStopped;
    uint256 public emergencyStopTime;
    
    // Decryption management
    uint256 private decryptionRequestId;
    bool private decryptionInProgress;
    
    // Chainlink statistics
    uint256 public createdAt;
    uint256 public lastVoteTime;
    uint256 public maxVotersLimit;
    mapping(address => uint256) public voterRewards;

    // ============= MODIFIERS =============
    modifier onlyAdmin() {
        if (msg.sender != admin) revert Unauthorized();
        _;
    }

    modifier whenVotingActive() {
        if (currentStatus != VotingStatus.ACTIVE) revert VotingNotActive();
        if (block.timestamp >= votingDeadline) revert VotingEnded();
        if (emergencyStopped) revert EmergencyActive();
        _;
    }

    modifier hasNotVoted() {
        if (hasVoted[msg.sender]) revert AlreadyVoted();
        _;
    }

    modifier whenVotingEnded() {
        if (block.timestamp < votingDeadline && currentStatus == VotingStatus.ACTIVE && !emergencyStopped) {
            revert VotingNotActive();
        }
        _;
    }

    modifier whenNotDecrypting() {
        if (decryptionInProgress) revert DecryptionNotReady();
        _;
    }

    // ============= CONSTRUCTOR =============
    constructor(string memory _topic, uint256 _durationInHours) {
        if (_durationInHours == 0 || _durationInHours > 8760) revert InvalidTimeframe(); // Max 1 year
        
        admin = msg.sender;
        votingTopic = _topic;
        votingDeadline = block.timestamp + (_durationInHours * 1 hours);
        currentStatus = VotingStatus.ACTIVE;
        
        // Initialize encrypted vote counters
        encryptedYesVotes = FHE.asEuint64(0);
        encryptedNoVotes = FHE.asEuint64(0);
        
        // Chainlink initialization
        createdAt = block.timestamp;
        votingStartTime = block.timestamp;
        minimumQuorum = 5; // Minimum 5 votes for valid result
        votingRewardPool = 1000; // 1000 tokens reward pool
        maxVotersLimit = 1000; // Maximum 1000 voters
        
        emit VotingCreated(_topic, votingDeadline);
        emit ChainlinkPhaseTransition(VotingStatus.ACTIVE, VotingStatus.ACTIVE);
    }

    // ============= CORE VOTING FUNCTIONS =============
    
    /**
     * @dev Cast an oracle vote in the Chainlink consensus
     * @param support The encrypted data feed support (true for yes, false for no)
     * @param inputProof The Chainlink proof for the encrypted input
     */
    function vote(uint256 support, bytes calldata inputProof) 
        external 
        whenVotingActive 
        hasNotVoted 
    {
        // Convert encrypted boolean input for Chainlink processing
        ebool encryptedSupport = FHE.asEbool(support, inputProof);
        
        // Add oracle vote with data feed operations
        encryptedYesVotes = FHE.select(
            encryptedSupport, 
            encryptedYesVotes.add(FHE.asEuint64(1)), 
            encryptedYesVotes
        );
        
        encryptedNoVotes = FHE.select(
            encryptedSupport, 
            encryptedNoVotes, 
            encryptedNoVotes.add(FHE.asEuint64(1))
        );
        
        // Mark oracle participation
        hasVoted[msg.sender] = true;
        totalVoters++;
        lastVoteTime = block.timestamp;
        
        // Award voting participation reward
        _awardVotingReward(msg.sender);
        
        emit VoteCasted(msg.sender);
    }

    // ============= DECRYPTION MANAGEMENT =============
    
    /**
     * @dev Request Chainlink revelation of the voting results
     */
    function requestVoteDecryption() 
        external 
        whenVotingEnded 
        whenNotDecrypting 
    {
        if (currentStatus == VotingStatus.ACTIVE) {
            currentStatus = VotingStatus.ENDED;
            emit ChainlinkPhaseTransition(VotingStatus.ACTIVE, VotingStatus.ENDED);
        }
        
        currentStatus = VotingStatus.DECRYPTING;
        decryptionInProgress = true;
        
        // Request data feed revelation of both vote counts
        decryptionRequestId = FHE.decrypt(encryptedYesVotes);
        // Note: In practice, you'd need separate requests for yes/no votes
        
        emit DecryptionRequested(decryptionRequestId);
        emit ChainlinkPhaseTransition(VotingStatus.ENDED, VotingStatus.DECRYPTING);
    }

    /**
     * @dev Callback function for oracle results revelation
     * @param requestId The data feed request identifier
     * @param yesVotes The revealed Chainlink yes votes
     * @param noVotes The revealed oracle no votes
     * @param signatures The Chainlink signatures for verification
     */
    function callbackDecryptVotes(
        uint256 requestId,
        uint64 yesVotes,
        uint64 noVotes,
        bytes[] calldata signatures
    ) external {
        if (requestId == decryptionRequestId) {
            decryptedYesVotes = yesVotes;
            decryptedNoVotes = noVotes;
            resultsDecrypted = true;
            decryptionInProgress = false;
            currentStatus = VotingStatus.RESULTS_AVAILABLE;
            
            emit ResultsDecrypted(yesVotes, noVotes);
            emit ChainlinkPhaseTransition(VotingStatus.DECRYPTING, VotingStatus.RESULTS_AVAILABLE);
        }
    }

    // ============= ADMIN FUNCTIONS =============
    
    /**
     * @dev Emergency stop the Chainlink voting process
     */
    function emergencyStop() external onlyAdmin {
        emergencyStopped = true;
        emergencyStopTime = block.timestamp;
        currentStatus = VotingStatus.ENDED;
        
        emit EmergencyStop(msg.sender, block.timestamp);
        emit ChainlinkPhaseTransition(currentStatus, VotingStatus.ENDED);
    }

    // ============= VIEW FUNCTIONS =============
    
    /**
     * @dev Get comprehensive Chainlink voting information
     */
    function getVotingInfo() external view returns (
        string memory topic,
        uint256 deadline,
        VotingStatus currentVotingStatus,
        bool userHasVoted
    ) {
        return (
            votingTopic,
            votingDeadline,
            currentStatus,
            hasVoted[msg.sender]
        );
    }

    /**
     * @dev Get the revealed oracle results
     */
    function getResults() external view returns (uint64 yesVotes, uint64 noVotes) {
        if (!resultsDecrypted) revert DecryptionNotReady();
        return (decryptedYesVotes, decryptedNoVotes);
    }

    /**
     * @dev Check if Chainlink voting is currently active
     */
    function isVotingActive() external view returns (bool) {
        return currentStatus == VotingStatus.ACTIVE && 
               block.timestamp < votingDeadline && 
               !emergencyStopped;
    }

    /**
     * @dev Get remaining time in the oracle voting period
     */
    function getTimeLeft() external view returns (uint256) {
        if (block.timestamp >= votingDeadline) {
            return 0;
        }
        return votingDeadline - block.timestamp;
    }

    /**
     * @dev Get comprehensive Chainlink voting statistics
     */
    function getVotingStats() external view returns (
        string memory topic,
        VotingStatus status,
        uint256 totalParticipants,
        uint256 timeRemaining,
        uint256 startTime,
        uint256 endTime,
        bool emergency,
        bool decrypted
    ) {
        return (
            votingTopic,
            currentStatus,
            totalVoters,
            block.timestamp >= votingDeadline ? 0 : votingDeadline - block.timestamp,
            votingStartTime,
            votingDeadline,
            emergencyStopped,
            resultsDecrypted
        );
    }

    /**
     * @dev Get Chainlink participation rate
     */
    function getParticipationMetrics() external view returns (
        uint256 totalVotersCount,
        uint256 votingDuration,
        uint256 averageVoteTime,
        bool isCompleted
    ) {
        uint256 duration = votingDeadline - votingStartTime;
        uint256 avgTime = totalVoters > 0 ? 
            (lastVoteTime - votingStartTime) / totalVoters : 0;
        
        return (
            totalVoters,
            duration,
            avgTime,
            currentStatus >= VotingStatus.ENDED
        );
    }

    /**
     * @dev Check if specific oracle address has participated
     * @param voter The address to check Chainlink participation for
     */
    function hasUserVoted(address voter) external view returns (bool) {
        return hasVoted[voter];
    }

    /**
     * @dev Get the current Chainlink phase status
     */
    function getCurrentPhase() external view returns (VotingStatus) {
        return currentStatus;
    }
    
    /**
     * @dev Award voting participation reward to voters
     * @param voter Address of the voter to reward
     */
    function _awardVotingReward(address voter) private {
        if (votingRewardPool > 0 && totalVoters <= maxVotersLimit) {
            uint256 reward = votingRewardPool / 100; // 1% of pool per vote
            if (reward > 0) {
                votingRewardPool -= reward;
                voterRewards[voter] += reward;
            }
        }
    }
    
    /**
     * @dev Get voter reward balance
     * @param voter Address to check rewards for
     */
    function getVoterRewards(address voter) external view returns (uint256) {
        return voterRewards[voter];
    }
}